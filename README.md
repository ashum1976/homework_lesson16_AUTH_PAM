
#   ДЗ по теме "Пользователи и группы. Авторизация и аутентификация"

## Задание:

PAM

1. Дать конкретному пользователю права работать с докером и возможность рестартить докер сервис
2. Запретить всем пользователям, кроме группы admin логин в выходные (суббота и воскресенье), без учета праздников.

___

## Решение:
1.
Дадим разрешение пользователю из группы tester, разрешения на запуск команды  /bin/systemctl restart docker, а так же возможность запускать программу docker. Для этого создадим отдельный файл tester в папке /etc/sudoers.d/, со следующим содержимым:

    Cmnd_Alias DOCKER = /bin/systemctl restart docker, /usr/bin/docker <---- алиас для использования в разрешениях на запуск.                                                
    %tester secsrv=(root) NOPASSWD: DOCKER <---- пользователям группы tester разрешено сделать пререзапуск сервиса docker, и выполнять программу "docker"

> в основном конфиг-файле /etc/sudoers должен быть установлен параметр includedir /etc/sudoers.d

2.
Для проверки доступа к системе пользователя, принадлежащего определённой группе (admin), будем использовать сторонний модуль pam_script, из репозитория epel-release. При работе модуля передаются переменные  PAM_USER, PAM_RUSER, PAM_RHOST, PAM_SERVICE, PAM_AUTHTOK, PAM_OLDAUTHTOK, PAM_TTY, and PAM_TYPE. Используем переменную PAM_USER, для получения имени пользователя, подключающегося к системе.   
Скрипт проверки располагается в дефолтовой директории /etc/pam-script.d/pam_script_auth и относится к категории auth, (pam_script_auth <--- "_auth" говорит об этом, в логике работы основного скрипта /etc/pam-script), поэтому в файл /etc/pam.d/sshd добавляем в начало строку:

      auth       required     pam_script.so

<details>

<summary>Скрипт проверки пользователя</summary>

      #!/usr/bin/env bash

      echo $PAM_USER >> /root/test
      if [[ $(grep $PAM_USER /etc/group | grep 'admin') ]]
          then
              if [[ $(date +%u) -ge 5 ]]
                  then
                      exit 1
                  else
                      exit 0
              fi
          else
              exit 0

      fi

</details>



#                      Общая теория, примеры, полезности.

- Authentication - Аутентификация, идентификация,процесс подтверждения пользователем своей“подлинности”. Ввод логина и пароля.
- Authorization - Авторизация, процесс наделения пользователя правами (предоставления доступа к каким- либо объектам)
- Accounting - Запись информации о произошедших событиях

gpasswd - управление группами, добавлять пользователя в группу или убирать из группы
newgrp - дать пользователю права новой группы на время;


<table>
<summary>Таблица типов файлов</summary>
<tr>
    <th>
      Flags
    </th>
    <th>
      Описание
    </th>   
</tr>

<tr>
    <td>l</td>
    <td>символическая ссылка</td>
</tr>

<tr>
    <td>d</td>
    <td>директория</td>
</tr>

<tr>
    <td>b</td>
    <td>блочное устройство</td>
</tr>

<tr>
    <td>c</td>
    <td>символьное устройство</td>
</tr>

<tr>
    <td>p</td>
    <td>канал ( fifo)</td>
</tr>

<tr>
    <td>s</td>
    <td>unix socket</td>
</tr>

</table>



capabilities

capabilities - это средства для управления привилегиями, которые в традиционных Unix-подобных системах были доступны только процессам, запущенным с правами root
(uid==0).

  **man capabilities**



В ядре Linux  все привилегии, обычно связываемые с суперпользователем, разделены на несколько частей, называемых мандатами (capabilities), которые можно разрешать и запрещать независимо друг от друга. Мандаты являются атрибутом нити.

[Обзор мандатов Linux](http://ru.manpages.org/capabilities/7)


Inheritable (наследуемые) — разрешения, которые могут наследовать потомки
Permitted (доступные) — разрешения, которые могут использоваться задачей
Effective (текущие, эффективные) — текущие действующие разрешения
Bounding (ограничивающий набор) — до Linux 2.6.25 ограничивающий набор был общесистемным атрибутом, общим для всех потоков, предназначенным для описания набора, за пределы которого разрешения расширяться не могут. В настоящее время это набор для каждой задачи и является лишь частью логики execve, подробности далее.
Ambient (наружные, начиная с Linux 4.3) — добавлены, чтобы легче предоставлять разрешения не-root пользователю, без использования setuid или файловых разрешений


- CAP_SYS_ADMIN - Разрешить диапазон системных административных операций
- CAP_SYS_BOOT - Разрешить вызовы к reboot
- CAP_SYS_CHROOT - Разрешить вызовы к chroot

capabilities
Флаги (битовая маска) установки дополнительных прав на
файлы и запущенные процессы, предоставляющие
расширенные системные права без использования suid (sudo)
В Linux каждый процесс (задача) имеет пять 64-битных чисел
(наборов), содержащих биты разрешений (до Linux 2.6.25 они
были 32-битными), которые можно посмотреть в
/proc/<pid>/status




#                   SUDO

##        Конфигурационный файл sudo

Программа sudo считывает конфигурацию из файла /etc/sudoers.
Чтобы открыть файл для редактирования наберите такую команду от имени суперпользователя:

        visudo

 Если в файле /etc/sudoers раскомментировать директиву includedir /etc/sudoers.d, то дополнительно настройки будут считываться из всех файлов в директории /etc/sudoers.d/
Основной синтаксис файла. Он состоит из двух типов строк, это псевдонимы, которые позволяют создавать списки пользователей и флагов, а также сами правила, которые задают как будет вести себя команда sudo. Синтаксис алиасов выглядит вот так:

        тип имя_алиаса = элемент1, элемент2, элемент3

Псевдонимы могут быть таких типов:

- User_Alias - псевдоним пользователей, которые будут использовать sudo;
- Runas_Alias - псевдоним пользователей, от имени которых будут выполняться команды;
- Host_Alias - псевдоним хоста;
- Cmnd_Alias - псевдоним команд;

___

####Описание разрешений для пользователей:

пользователь хост  = (другой_пользователь:группа) команды

  - "Пользователь" - указывает пользователя или группу, для которых мы создаем правило
  - "Хост" - компьютер, для которого будет действовать это правило (можно создать один файл для многих компьютеров, просто приписывая для какого создаём правила)
  - "Другой" пользователь - под видом какого пользователя первый может выполнять команды (обычно root, но можно прописать и другого)
  - "Команды" - разрешенные команды. Вместо любого из параметров может использоваться алиас

Пример записи для выполнения команд:

      ALL ALL = (root) NOPASSWD: /bin/mount  

      разрешить всем пользователям выполнять команду mount с sudo без пароля

Также можно запретить выполнять именно эту команду вообще с помощью флага NOEXEC:

      ALL ALL = (root) NOEXEC /bin/mount

___

###       Параметры конфигурационного файла /etc/sudoers

- Defaults !root_sudo -  Суперпользователь не может выполнять sudo
- Defaults set_home - Изменять домашнюю директорию для целевого пользователя ( по умолчанию остается папка текущего пользователя в качестве домашней директории)
- Defaults !preserve_groups - Сохранять список групп текущего пользователя
- Defaults rootpw - Запрашивать пароль суперпользователя вместо пароля пользователя
- Defaults passwd_tries=5 - Задать количество попыток ввода пароля перед тем, как sudo прекратит работу (по умолчанию - 3)
- Defaults timestamp_timeout=10 - Количество минут, которое пройдет перед тем, как sudo будет спрашивать пароль снова (по умолчанию 5)
- Defaults passwd_timeout=10 - Количество минут, пока sudo будет ожидать повторного ввода пароля при неправильном вводе
- Defaults passprompt="Ваш пароль:" - Сообщение, которое будет выводится при запросе пароля
- Defaults runas_default="пользователь" - Можно указать другого пользователя, не root, от которого будут выполняться все команды
- Defaults logfile=/var/log/sudo - Записывать в лог все попытки подключения к sudo
- Defaults  use_pty - Запуск команд только с помощью psuedo-pty
- Defaults requiretty - Включить sudo из реального tty, но не с помощью скриптов cron или cgi-bin
- Defaults secure_path="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/snap/bin" - Безопасная переменная среды PATH
- Defaults  badpass_message="Password is wrong, please try again" - Сообщение отображаемо при вводе неправильного пароля


#                   PAM


Настройка PAM выполняется в главном конфигурационном файле /etc/pam.conf и подключаемых из каталога /etc/pam.d, название каждого файла в котором точно соответствует названию программы, которая использует модуль pam для аутентификации

-  синтаксис конфигурации:  

   _<Тип модуля> <Флаг контроля> <Путь к модулю> <Параметры модуля>_

        #%PAM-1.0
        auth       substack     password-auth
        auth       include      postlogin
        account    required     pam_sepermit.so
        account    required     pam_nologin.so
        account    include      password-auth
        password   include      password-auth
        # pam_selinux.so close should be the first session rule
        session    required     pam_selinux.so close
        session    required     pam_loginuid.so
        # pam_selinux.so open should only be followed by sessions to be executed in the user context
        session    required     pam_selinux.so open env_params
        session    required     pam_namespace.so
        session    optional     pam_keyinit.so force revoke
        session    optional     pam_motd.so
        session    include      password-auth
        session    include      postlogin



**Тип модуля** — варианты:
  - **auth** - это действия связанные непосредственно с аутентификацией. То есть действия или функции которые позволяют определить, что вы это вы. Это может быть аутентификация по паролю, по смарт-карте, биометрическая аутентификация (отпечаток пальца и т.д.) и другие.
  - **account** - это действия связанные с управлением учетными записями. Например, даже если вы аутентифицировались в системе, то вашей учетной записи можно поставить запрет на работу в определенное время суток. Или разрешить заходить в консольном режиме, но запретить заходить в графическом режиме
  - **session** - действия этой группы осуществляют выделение пользователю необходимых для работы ресурсов
  - **password** - действия, которые реализуют изменение аутентификационных данных пользователя. Чаще всего это действия по управлению паролями пользователя. Содержит функции, например, обновление пароля пользователя, проверка подлинности.  

**Флаг контроля** — варианты:
  - **required** - требуется для успешной авторизации и если закончится ошибкой, то в целом pam вернет отказ
  - **requisite** - то же самое, что и required с резкой остановкой последующих правил
  - **sufficient** - достаточный для проверки подлинности, то есть если завершится успешно, pam вернет успех
  - **optional** - дополнительный модуль — результат его работы не влияет на ответ pam; может использоваться для вывода дополнительной информации
  - **include** - подключение строк из другого файла
  - **substack** - подключение строк из другого файла, но только того же типа, что наша строка.  

**Путь к модулю** — путь может быть полным (от корня /) или относительно каталога /usr/lib/security и/или /usr/lib64/security.  

**Параметры модуля** — для указания дополнительных параметров. Например, некоторым модулям можно передать файлы конфигурации.
